# %% [markdown]
# ## Gated Recurrent Unit Model for Weather Forecast Prediction
# 
# ### This document explains the GRU Model and is an addendum to the main PDF
# 
# #### It was decided to split the notebook into two parts, one using PyTorch and the other Tensorflow.  For information on the dataset and preprocessing please refer to the main document.  This model was trained on an Nvidia 3060 Ti GPU with 8GB GDDR6 memory and 4864 CUDA cores.

# %%
# Weather Forecasting GRU Model using PyTorch
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, Dataset, Subset

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import sklearn
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, mean_absolute_error

import warnings
import streamlit as st
import random
from datetime import datetime, timedelta
import base64

# %%
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f'Using device: {device}')
torch.cuda.manual_seed(55)
warnings.filterwarnings('ignore')

# %%
# Dataset, convert to date, split into day, week, month, X and y
class TemperatureData:
    def __init__(self, file_path):
        self.df = pd.read_csv(file_path)
        self._process()
    
    def _process(self):
        """All processing in one compact method"""
        self.df['Date'] = pd.to_datetime(self.df['Date'])
        self.df['Day_of_Year'] = self.df['Date'].dt.dayofyear
        self.df['Day_of_Week'] = self.df['Date'].dt.dayofweek  
        self.df['Month'] = self.df['Date'].dt.month
        self.df['Next_Day_Temp'] = self.df['Temperature'].shift(-1)
        
        self.X = self.df[['Temperature', 'Day_of_Year', 'Day_of_Week', 'Month']]
        self.y = self.df['Next_Day_Temp'].values.reshape(-1, 1)

data = TemperatureData("Toronto_Temperature.csv")

# %%
# Create overlapping circular sequences (maintain same # of samples)
def sequence(data_df, seq_len=30):
    data_array = data_df.values if hasattr(data_df, 'values') else data_df  # convert to numpy array
    X = []
    for i in range(len(data_array)):
        indices = [(i + j) % len(data_df) for j in range(seq_len)]
        X.append(data_array[indices])
    return np.array(X)
X_seq = sequence(data.X)
# X_seq.shape

# %%
# Split data, fit + transform, convert to tensors
class TimeSeriesPreprocessor:
    def __init__(self, device, test_size=0.2, random_state=55):
        self.device = device
        self.test_size = test_size
        self.random_state = random_state
        self.X_scaler = StandardScaler()
        self.y_scaler = StandardScaler()
    
    def process(self, X_seq, y):
        # Split data
        X_train, X_test, y_train, y_test = train_test_split(
            X_seq, y, test_size=self.test_size, random_state=self.random_state, shuffle=False
        )
        
        train_shape, test_shape = X_train.shape, X_test.shape
        
        # Scale features
        X_train = self.X_scaler.fit_transform(X_train.reshape(-1, 4)).reshape(train_shape)
        X_test = self.X_scaler.transform(X_test.reshape(-1, 4)).reshape(test_shape)
        
        # Scale target
        y_train = self.y_scaler.fit_transform(y_train.reshape(-1, 1)).flatten()
        y_test = self.y_scaler.transform(y_test.reshape(-1, 1)).flatten()
        
        # Convert to tensors and move to device
        tensors = {}
        for name, data in [('X_train', X_train), ('X_test', X_test), 
                          ('y_train', y_train), ('y_test', y_test)]:
            tensors[name] = torch.tensor(data, dtype=torch.float32).to(self.device)
        
        print(f"X tensor shape: {X_train.shape} (train), {X_test.shape} (test)")
        print(f"y tensor shape: {y_train.shape} (train), {y_test.shape} (test)")
        
        return tensors['X_train'], tensors['X_test'], tensors['y_train'], tensors['y_test']

preprocessor = TimeSeriesPreprocessor(device)
X_train, X_test, y_train, y_test = preprocessor.process(X_seq, data.y)

# %%
# Create Dataset and DataLoader
class TimeSeriesDataset(Dataset):
    def __init__(self, X, y):
        self.X = X
        self.y = y

    def __len__(self):
        return len(self.X)

    def __getitem__(self, idx):
        return self.X[idx], self.y[idx]

train_dataset = TimeSeriesDataset(X_train, y_train)
test_dataset = TimeSeriesDataset(X_test, y_test)

train_loader = DataLoader(train_dataset, batch_size=32, shuffle=False)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

# %%
train_features, train_labels = next(iter(train_loader))
print(f"Feature batch shape: {train_features.size()}")
print(f"Labels batch shape: {train_labels.size()}")

# %%
b64 = base64.b64encode(open("image.png", "rb").read()).decode()
img_tag = f'<img src="data:image/png;base64,{b64}"/>'

# %% [markdown]
# ### GRU Architecture  
# <img src="<img src="data:image/png;base64,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"/>

# %% [markdown]
# #### The GRU Model architecture consists of 5 layers: 1 recurrent GRU layer with 2 stacked stacked conceptual layers (num_layers = 2) and 4 standard feedforward layers.  After going through the GRU layer, it enters a Dropout layer then enters the first Linear layer.  This layer reduces the number of outputs by half.  After that it enters a ReLU activation layer, a second Dropout layer, and finally the second Linear layer.  Here the output is reduced to 1 neuron.  The final hyperparameters used are: Input_size = 4, hidden_size = 20, dropout = 0.3, learning rate = 1e-3, weight decay = 1e-5.  The loss function used is Mean Squared Error and the optimizer is AdamW.

# %%
# GRU model architecture
class GRUModel(nn.Module):
    def __init__(self, input_size, hidden_size, output_size, dropout, num_layers):
        super(GRUModel, self).__init__()
        self.num_layers = num_layers
        self.hidden_size = hidden_size
        self.gru = nn.GRU(input_size, hidden_size, num_layers, batch_first=True, dropout=dropout if num_layers > 1 else 0)  # GRU layer(s) have built-in activation functions
        self.fc1 = nn.Linear(hidden_size, hidden_size // 2)
        self.fc2 = nn.Linear(hidden_size // 2, output_size)
        self.dropout = nn.Dropout(dropout)
        self.relu = nn.ReLU()

    def forward(self, x):
        # Initialize hidden state
        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        
        # Forward through GRU
        out, _ = self.gru(x, h0) 
        
        # Take the last time step only (for sequence-to-vector)
        out = out[:, -1, :]  # shape: [batch, hidden_size]

        out = self.dropout(out)  # Apply dropout after GRU (good practice)
        out = self.fc1(out)
        out = self.relu(out)
        out = self.dropout(out)
        out = self.fc2(out)
        
        return out

# %% [markdown]
# #### NaN values would cause the test set to not compute a loss so it was replaced with the mean of the dataset.  Because the input was the sequence of 30 days before to predict the next day's weather, there is always one NaN value from the last sequence in the dataset not having an output.

# %%
# Find and replace NaN values (1 from the last row not having a tomorrow forecast)
if hasattr(test_dataset, 'X') and hasattr(test_dataset, 'y'):
    nan_mask = torch.isnan(test_dataset.y)
    if nan_mask.any():
        mean_value = test_dataset.y[~nan_mask].mean()
        test_dataset.y[nan_mask] = mean_value
        print(f"Replaced {nan_mask.sum().item()} NaN values with mean: {mean_value.item()}")
    else:
        print("No NaN values found in test_dataset.targets")

# Verify no NaN values remain
nan_count = 0
for i in range(len(test_dataset)):
    _, y_sample = test_dataset[i]
    if torch.isnan(y_sample).any():
        nan_count += 1
print(f"NaN values after cleaning: {nan_count}")

# %%
# Initialize the model + set hyperparameters + training loop
class GRUModelTrainer:
    def __init__(self, **config):
        self.model = GRUModel(**config).to(config.get('device', 'cuda'))
        self.criterion = nn.MSELoss()
        self.optimizer = optim.AdamW(self.model.parameters(), lr=1e-3, weight_decay=1e-5)
        self.losses = {'train': [], 'test': []}
        self.device = config.get('device', 'cuda')
    
    def train(self, num_epochs, train_loader, test_loader):
        for epoch in range(num_epochs):
            # Training step
            self.model.train()
            for X, y in train_loader:
                X, y = X.to(self.device), y.to(self.device)
                self.optimizer.zero_grad()
                loss = self.criterion(self.model(X), y.unsqueeze(-1))
                loss.backward()
                torch.nn.utils.clip_grad_norm_(self.model.parameters(), 1.0)
                self.optimizer.step()
            
            # Evaluation
            self.model.eval()
            for mode, loader in [('train', train_loader), ('test', test_loader)]:
                total, n = 0.0, 0
                with torch.no_grad():
                    for X, y in loader:
                        X, y = X.to(self.device), y.unsqueeze(-1).to(self.device)
                        total += self.criterion(self.model(X), y).item() * X.size(0)
                        n += X.size(0)
                self.losses[mode].append(total / n)
            
            if (epoch + 1) % 20 == 0:
                print(f'Epoch {epoch+1}: train {self.losses["train"][-1]:.4f}, test {self.losses["test"][-1]:.4f}')

trainer = GRUModelTrainer(input_size=4, hidden_size=20, output_size=1, dropout=0.3, num_layers=2)
trainer.train(300, train_loader, test_loader)

# %% [markdown]
# #### As can be seen by plotting the training and test loss over epochs, there was a rapid decrease in loss in both sets until around 50 epochs, until when convergence can be seen to occur.

# %%
# Plot train + test losses
class LossPlotter:
    @staticmethod
    def plot(trainer, figsize=(10, 5)):
        plt.figure(figsize=figsize)
        plt.plot(trainer.losses['train'], label='Training Loss')
        plt.plot(trainer.losses['test'], label='Test Loss')
        plt.xlabel('Epochs'); plt.ylabel('Loss')
        plt.title('Training and Test Loss'); plt.legend(); plt.grid(True)
        plt.show()

LossPlotter.plot(trainer)

# %% [markdown]
# ## Results

# %% [markdown]
# #### This is a visualization of 10 random samples from the test set, plotted with predicted vs. actual temperature with the red dotted line representing perfect predictions.

# %%
# 10 random sample predictions
class ModelEvaluator:
    def __init__(self, trainer):
        self.trainer = trainer
        self.y_scaler = preprocessor.y_scaler
        self.device = trainer.device
    
    def plot_random_predictions(self, X_test, y_test, n_samples=10):
        # Get random samples
        random_indices = random.sample(range(len(X_test)), n_samples)
        X_random, y_actual = X_test[random_indices], y_test[random_indices]
        
        # Convert to tensors and predict
        X_tensor = torch.tensor(X_random, dtype=torch.float32).to(self.device)
        with torch.no_grad():
            predictions = self.trainer.model(X_tensor).squeeze(-1)
        
        # Unscale
        predictions = self.y_scaler.inverse_transform(predictions.cpu().numpy().reshape(-1, 1)).flatten()
        y_actual = self.y_scaler.inverse_transform(y_actual.cpu().numpy().reshape(-1, 1)).flatten()
        
        # Plot
        plt.figure(figsize=(10, 6))
        plt.scatter(y_actual, predictions, alpha=0.7, s=100, c='blue', edgecolors='black')
        
        # Perfect prediction line
        min_val, max_val = min(y_actual.min(), predictions.min()), max(y_actual.max(), predictions.max())
        plt.plot([min_val, max_val], [min_val, max_val], 'r--', label='Perfect Prediction')
        
        plt.xlabel('Actual Temperature (C)'); plt.ylabel('Predicted Temperature (C)')
        plt.title(f'Actual vs Predicted Temperatures ({n_samples} Random Samples)')
        plt.legend(); plt.grid(True, alpha=0.3)
        plt.show()

evaluator = ModelEvaluator(trainer)
evaluator.plot_random_predictions(X_test, y_test, n_samples=10)

# %% [markdown]
# #### The Root Mean Squared Error (RMSE) and Mean Squared Error (MAE) were 1.011 and 0.778 for the test set, respectively.  With the test range being 38.05 degrees Celcius, this means the RSME as a percentage of the range was 2.7% and the MAE as a % of the Range was 2.0%.  As RMSE is 1.28 MAE, the variance (squared error) is fairly modest.  In all, this trained model would be deployment-ready for applications that allow +/- 1 degrees of uncertainty.

# %%
# Evaluation metrics
class ModelEvaluator:
    def __init__(self, trainer):
        self.trainer = trainer
        self.y_scaler = preprocessor.y_scaler
    
    def evaluate(self, X_test, y_test):
        self.trainer.model.eval()
        with torch.no_grad():
            y_test_pred = self.trainer.model(X_test)
        
        # Unscale predictions and actuals
        y_test_pred = self.y_scaler.inverse_transform(y_test_pred.cpu().detach().numpy().reshape(-1, 1)).ravel()
        y_test_real = self.y_scaler.inverse_transform(y_test.cpu().numpy().reshape(-1, 1)).ravel()
        
        # Calculate metrics
        rmse = np.sqrt(sklearn.metrics.mean_squared_error(y_test_real, y_test_pred))
        mae = sklearn.metrics.mean_absolute_error(y_test_real, y_test_pred)
        
        # Calculate range percentages
        min_temp, max_temp = np.min(y_test_real), np.max(y_test_real)
        data_range = max_temp - min_temp
        
        # Print results
        print(f"Test RMSE: {rmse:.3f}, Test MAE: {mae:.3f}")
        print(f"Test Range: {data_range:.2f}C")
        print(f"RMSE as % of Range: {(rmse / data_range) * 100:.1f}%")
        print(f"MAE as % of Range: {(mae / data_range) * 100:.1f}%")
        
        return {'rmse': rmse, 'mae': mae, 'data_range': data_range}

evaluator = ModelEvaluator(trainer)
metrics = evaluator.evaluate(X_test, y_test)

# %% [markdown]
# ## Demo

# %% [markdown]
# #### This is the streamlit demo for the GRU Model.  Users can input any date range from March 18, 2018 (the beginning of the dataset) to December 31, 2030 and the demo will predict a temperature.  For the purposes of the demo, because the input requires a 30-day sequence and the test data did not have a full year of data, a random year-long sequence of data was picked from the training data.  When the predicted date was chosen, the prediction app would generate a 30-day sequence from the 15 days before and after the predicted date to have a more seasonal approach to the output.  Due to the way the demo works, the year of the predicted date does not matter, simply the day of year, month, and day of week.

# %%
# Streamlit app for user input and prediction
def random_365_sequence(dataset):
    n = len(dataset)
    start = random.randint(0, n - 1)          # random start index
    indices = [(start + i) % n for i in range(365)]  # wrap-around indices
    subset = Subset(dataset, indices)         # keeps original transforms
    return subset

seq_subset = random_365_sequence(train_dataset)
test_dataset1 = torch.utils.data.DataLoader(seq_subset, batch_size=32, shuffle=False)

def create_test_dates(test_dataset1):
    start_date = datetime(2018, 3, 18)
    test_dates = [start_date + timedelta(days=i) for i in range(len(test_dataset1))]
    return test_dates

def find_seasonal_match(target_date, test_dates):
    # Find the best seasonal match for a target date based on day of year
    target_doy = target_date.timetuple().tm_yday
    
    best_match_index = 0
    best_match_diff = 365  # Initialize with maximum possible difference
    
    for i, test_date in enumerate(test_dates):
        test_doy = test_date.timetuple().tm_yday
        day_diff = min(abs(test_doy - target_doy), 365 - abs(test_doy - target_doy))
        
        if day_diff < best_match_diff:
            best_match_diff = day_diff
            best_match_index = i
    
    return best_match_index, best_match_diff

def prepare_seasonal_input(selected_date, test_dates, test_dataset1, sequence_length=30):
    # Prepare input using seasonal patterns with looping
    day_before = selected_date - timedelta(days=1)
    
    # Find the best seasonal match
    center_index, day_diff = find_seasonal_match(day_before, test_dates)
    
    input_sequence = []
    actual_temperatures = []
    dates_used = []
    seasonal_dates = []
    
    # Build the 30-day window centered around the seasonal match
    half_window = sequence_length // 2
    
    for i in range(sequence_length):
        offset = i - half_window
        data_index = (center_index + offset) % len(test_dataset1)
        
        # Get the data
        features, temp = test_dataset1[data_index]

        # Move tensors to CPU and convert to numpy
        if torch.is_tensor(features):
            features = features.cpu().numpy()
        if torch.is_tensor(temp):
            temp = temp.cpu().item()
        else:
            temp = float(temp)
        input_sequence.append(features)
        actual_temperatures.append(temp)
        
        # Store the actual date used from test data
        dates_used.append(test_dates[data_index])
        
        # Create synthetic date for display (same seasonal pattern, different year)
        synthetic_date = test_dates[data_index].replace(year=selected_date.year - 1)
        seasonal_dates.append(synthetic_date)
    
    return input_sequence, actual_temperatures, dates_used, seasonal_dates, day_diff

def main():
    st.markdown(
        "<h1 style='text-align: center;'> Weather Temperature Predictor for Toronto </h1>",
        unsafe_allow_html=True
)
      
    # Create test dates
    test_dates = create_test_dates(test_dataset1)
    max_actual_date = test_dates[-1] if test_dates else datetime(2022, 12, 31)
    
    # Center container for inputs
    center_container = st.container()
    with center_container:
        st.subheader("Select Prediction Date")
        selected_date = st.date_input(
            "Choose a date:",
            value=max_actual_date.date() + timedelta(days=1),
            min_value=test_dates[0].date() if test_dates else datetime(2020, 1, 1).date(),
            max_value=datetime(2030, 12, 31).date(),
            label_visibility="collapsed"
        )
        
        # Center the button using columns
        col1, col2, col3 = st.columns([2, 1, 2])
        with col2:
            predict_button = st.button(
                " Predict Temperature", 
                use_container_width=True,
                type="primary"
            )
    
    st.markdown("---")
    
    if predict_button:
        with st.spinner("Analyzing seasonal patterns..."):
            # Prepare input using seasonal matching
            input_scaled, actual_temps, dates_used, seasonal_dates, day_diff = prepare_seasonal_input(
                selected_date, test_dates, test_dataset1
            )
            
            if input_scaled is not None:
                # Make prediction
                input_tensor = torch.FloatTensor(input_scaled)
                with torch.no_grad():
                    input_tensor = input_tensor.to(device)
                    prediction = model(input_tensor)
                    pred_norm = prediction[0, 0].cpu().numpy() 
                    prediction1 = y_scaler.inverse_transform([[pred_norm]])[0, 0]  # Unscale prediction
                    
                # Display results
                st.success(f"## Predicted Temperature: **{prediction1:.1f}C**")
                
                # Information about the prediction
                with st.expander(" Prediction Details"):
                    st.write(f"**Selected Date:** {selected_date.strftime('%Y-%m-%d')}")
                    st.write(f"**Seasonal Match Quality:** {day_diff} day(s) from closest historical pattern")
                    st.write(f"**Input Window:** 30 days ending {seasonal_dates[-1].strftime('%Y-%m-%d')}")
                
                # Visualization
                actual_temps = y_scaler.inverse_transform(np.array(actual_temps).reshape(-1, 1)).flatten()  # Unscale actual temperatures for display
                fig, ax = plt.subplots(figsize=(10, 4))
                ax.plot([d.strftime('%m-%d') for d in seasonal_dates], actual_temps, 
                       marker='o', linewidth=2, markersize=4, color='steelblue')
                ax.set_xlabel('Date (Month-Day)')
                ax.set_ylabel('Temperature (C)')
                ax.set_title('30-Day Input Pattern (Seasonal Data)')
                ax.grid(True, alpha=0.3)
                plt.xticks(rotation=45)
                plt.tight_layout()
                st.pyplot(fig)
                
                # Data table
                with st.expander(" View Input Data"):
                    display_df = pd.DataFrame({
                        'Date': [d.strftime('%Y-%m-%d') for d in seasonal_dates],
                        'Reference Date Used': [d.strftime('%Y-%m-%d') for d in dates_used],
                        'Temperature (C)': actual_temps,
                        'Day of Year': [d.timetuple().tm_yday for d in seasonal_dates]
                    })
                    st.dataframe(display_df, use_container_width=True)

if __name__ == "__main__":
    test_dataset1 = TimeSeriesDataset(X_train, y_train)
    main()

# %% [markdown]
# ## Comparison to other models

# %% [markdown]
# #### As seen in the main document, Ridge Regression had an RMSE and MAE of 2.92 and 2.35, Random Forest had 3.27 and 2.55, XGBoost had 3.44 and 2.73, and the hybrid CNN + LSTM model had 1.05 and 0.84.  By comparison, the GRU model had an RMSE and MAE of 0.91 and 0.69.  However, the differences between the deep learning models is insignificant as RMSE and MAE can vary slightly depending on run-to-run variance.  The GRU, as a type of Recurrent Neural Network, is specialized towards modeling temporal data and finding sequential patterns over time.  As a result, its stronger performance over the traditional machine learning models such as Random Forest are expected.  Both Deep Learning models (GRU and CNN+LSTM hybrid) performed very well at typically around or under 1 degree Celcius error (squared).  The two models compared favourably with each other, despite the GRU model being considerably simpler (5 layers vs. 12 layers).

# %% [markdown]
# ## Next steps

# %% [markdown]
# #### Both the model and the prediction app have shortcomings which could be addressed as future steps towards continuing the project.  Firstly, the model was designed to use 30-day sequences as input and a single value for the next day forecast.  This could be improved by generating a sequence of future forecasts (e.g. a full week in advance).  Furthermore, weather-specific complexities were not added.  As such, the model could be improved with more detailed data from the days such as incorporating humidity, wind, etc.  For the prediction app, it could be improved by detecting yearly weather patterns (e.g. from global warming) and changing its output accordingly.  Furthermore, a more sophisticated method could be used as input for the weather forecast prediction rather than using the 15 days before and after from a past testing set as input data.  Ideally, real-life data from the previous 30 days would be used to generate a future forecast.  For extremely far forecasts (e.g. years in advance) weather data from many decades would likely be required.


